# 🤩TIL (Today I Learned)

# 👍 새롭게 배운 것 (키워드)

## 🌀 비동기 처리에 대해서

- 비동기 프로그래밍
- 콜백함수
- 이벤트 루프
- 매크로큐 VS 마이크로큐
- 매크로태스크 VS 마이크로태스크

# 📖오늘 배운 내용

## 1. 비동기 프로그램의 개념

### ✅ 비동기 프로그래밍(Asynchronous Programming)

비동기 프로그래밍은 **작업이 끝날 때까지 기다리지 않고 다음 코드를 실행하는 방식**을 의미해.

---

### 🔹 **동기(Synchronous) vs 비동기(Asynchronous)**

|           | **동기(Synchronous)**               | **비동기(Asynchronous)**              |
| --------- | ----------------------------------- | ------------------------------------- |
| 실행 방식 | 하나의 작업이 끝나야 다음 작업 실행 | 작업을 시작하고 기다리지 않음         |
| 코드 흐름 | 순차적으로 실행                     | 콜백, 프로미스, async/await 사용      |
| 예시      | 파일 읽기 후 다음 코드 실행         | 파일 읽기 요청 후 다른 코드 실행 가능 |

---

### 🔹 **비동기 프로그래밍을 위한 주요 기법**

1. **콜백(Callback)** – 특정 작업이 끝난 후 실행할 함수를 전달
2. **프로미스(Promise)** – 비동기 작업의 완료 여부를 다룰 수 있는 객체
3. **async/await** – 프로미스를 더 직관적으로 다룰 수 있는 문법

---

### 🔹 **예제: 비동기 vs 동기**

#### 🛑 동기 코드 (Blocking)

```js
console.log("Start");
for (let i = 0; i < 1e9; i++) {} // 오래 걸리는 작업
console.log("End");
```

출력

```sql
Start
(오래 기다림)
End
```

#### ✅ 비동기 코드 (Non-Blocking)

```js
console.log("Start");
setTimeout(() => console.log("Async Task Done"), 1000);
console.log("End");
```

출력

```sql
Start
End
Async Task Done (1초 후)
```

### 🎯 결론

- **비동기 프로그래밍은 성능을 최적화하는 핵심 개념!**
- **콜백 → 프로미스 → async/await 순으로 발전**
- **적절한 비동기 처리를 하지 않으면 UI가 멈추거나 성능 저하 발생 가능** 🚀

---

## 2. 콜백 함수

### ✅ 콜백 함수(Callback Function)

콜백 함수는 **다른 함수의 인자로 전달되어 실행되는 함수**를 의미해. 주로 비동기 프로그래밍에서 **어떤 작업이 끝난 후에 실행해야 할 작업**을 지정하기 위해 사용돼.

---

### 🔹 **콜백 함수의 개념**

- **고차 함수(Higher-Order Function)**에서 사용되며, **인자로 다른 함수를 받는 함수**를 말해.
- **비동기 작업이 완료된 후**에 실행해야 할 동작을 정의할 수 있게 해.
- 콜백 함수는 **순차적으로 실행되어야 할 작업**을 **동기적** 또는 **비동기적**으로 처리할 때 매우 유용해.

---

### 🔹 **콜백 함수 예시**

#### 🛑 **기본적인 콜백 함수 사용**

콜백 함수는 **다른 함수의 인자로 전달되어 실행**된다.

```js
function greet(name, callback) {
  console.log(`Hello, ${name}!`);
  callback();
}

function sayBye() {
  console.log("Goodbye!");
}

greet("Alice", sayBye);
```

출력:

```
Hello, Alice!
Goodbye!
```

- greet 함수는 이름을 출력한 후 sayBye 콜백 함수를 실행해.
- callback()은 함수의 실행을 다른 함수에 위임하는 방식이야.

---

### 🔹 비동기 콜백 (setTimeout 활용)

콜백 함수는 비동기 작업을 처리할 때 자주 사용된다. 예를 들어, setTimeout은 일정 시간이 지난 후 콜백 함수를 실행한다.

```js
console.log("Start");

setTimeout(() => {
  console.log("Callback executed!");
}, 2000);

console.log("End");
```

출력:

```sql
Start
End
(2초 후) Callback executed!
```

- **setTimeout**은 2초 후 콜백 함수를 실행해.
- 비동기적으로 동작하므로 **"End"**가 먼저 출력된 후 2초 후에 콜백이 실행돼.

---

### 🔹 콜백 함수의 문제점 - 콜백 지옥(Callback Hell)

콜백 함수가 중첩될 경우 코드의 가독성과 유지보수성이 떨어지게 돼. </br>이를 콜백 지옥이라 부른다.

```js
setTimeout(() => {
  console.log("Step 1");
  setTimeout(() => {
    console.log("Step 2");
    setTimeout(() => {
      console.log("Step 3");
    }, 1000);
  }, 1000);
}, 1000);
```

- 위 코드는 콜백 함수가 계속 중첩되면서 가독성이 떨어지고 오류를 추적하기 어려워지지.
- 이런 문제를 해결하려면 **Promise**나 **async/await**을 사용해.

---

### 🔹 콜백 함수의 장점

- **비동기 작업의 처리**: I/O 작업이나 네트워크 요청 같은 비동기 작업 후 결과를 처리하는 데 유용하다.
- **구조적인 코드 작성**: 고차 함수에서 콜백을 사용하면 함수의 재사용성을 높일 수 있다.
- **유연한 코드 작성**: 콜백 함수는 다른 함수들에 동적으로 전달되어 다양한 방식으로 활용될 수 있다.

---

### 🔹 콜백 함수의 단점

- **콜백 지옥**: 콜백이 중첩되면 코드가 복잡해지고, 가독성이 떨어지며 디버깅이 어려워진다.
- **오류 처리 어려움**: 콜백 함수 내에서 발생하는 오류를 처리하기 복잡할 수 있다.
- **비동기 코드의 흐름 추적 어려움**: 비동기 작업의 흐름을 추적하기 어려워 코드를 이해하는 데 어려움이 있다.

---

### 🎯 결론

- 콜백 함수는 다른 함수에 전달되어 실행되는 함수로, 주로 비동기 프로그래밍에서 사용된다.
- 비동기 처리에서 중요한 역할을 하지만, 중첩될 경우 콜백 지옥 문제를 일으킬 수 있다.
- 이 문제를 해결하기 위해 Promise나 async/await을 사용해 가독성을 개선할 수 있다. 🚀

---

## 3. 이벤트 루프

### ✅ 이벤트 루프(Event Loop)

이벤트 루프는 **비동기 코드의 실행 흐름을 관리하는 메커니즘**으로, 자바스크립트의 **단일 스레드**에서 비동기 작업을 처리하는 중요한 역할을 해. 자바스크립트는 **동기적 코드**와 **비동기적 코드**를 구분하여 순차적으로 실행한다. 이벤트 루프는 콜 스택과 큐(대기열)의 협력으로 비동기 작업을 처리한다.

---

### 🔹 **이벤트 루프의 동작 흐름**

1. **콜 스택(Call Stack)**: 실행 중인 함수들이 쌓이는 곳.
2. **이벤트 큐(Event Queue)**: 비동기 작업이 끝난 후 실행할 콜백 함수들이 대기하는 곳.
3. **이벤트 루프(Event Loop)**: 콜 스택이 비어 있으면 이벤트 큐에서 함수를 하나씩 꺼내 콜 스택에 넣어 실행.

---

### 🔹 **이벤트 루프 예시**

```js
console.log("Start");

setTimeout(() => {
  console.log("Timeout 1");
}, 1000);

setTimeout(() => {
  console.log("Timeout 2");
}, 0);

console.log("End");
```

출력:

```sql
Start
End
Timeout 2
Timeout 1
```

동작 설명:

- console.log("Start")와 console.log("End")는 동기적으로 실행되며 즉시 출력된다.
- setTimeout은 비동기 함수로 이벤트 큐에 대기하게 되며, 콜 스택이 비어야 실행된다.
- Timeout 2가 먼저 출력된 후, 1초 후 Timeout 1이 출력된다.

### 🎯 결론

## 이벤트 루프는 자바스크립트에서 비동기 작업을 처리할 때 중요한 역할을 하며, 콜 스택과 이벤트 큐를 관리하여 코드의 실행 순서를 제어한다.

### ✅ 매크로큐(Macro Queue)와 마이크로큐(Micro Queue)

매크로큐와 마이크로큐는 자바스크립트의 **이벤트 루프**에서 중요한 역할을 하는 두 가지 대기열이다. 둘 모두 비동기 작업이 완료된 후 콜백 함수가 실행되는 순서를 관리하지만, **우선순위**에서 차이가 있다.

---

## 4. 매크로큐 VS 마이크로큐

### 🔹 **매크로큐(Macro Queue)**

- 매크로큐는 **일반적인 비동기 작업**(예: `setTimeout`, `setInterval`)의 콜백 함수들이 대기하는 큐이다.
- **우선순위가 낮다**. 콜 스택이 비어있을 때만 실행된다.

---

### 🔹 **마이크로큐(Micro Queue)**

- 마이크로큐는 **미세한 비동기 작업**(예: `Promise`, `process.nextTick` 등)의 콜백 함수들이 대기하는 큐이다.
- **매크로큐보다 우선순위가 높다**. 마이크로큐의 콜백 함수는 콜 스택이 비어있고 매크로큐가 대기 중이라도 우선적으로 실행된다.

---

### 🔹 **매크로큐와 마이크로큐의 동작 예시**

```js
console.log("Start");

setTimeout(() => {
  console.log("Timeout 1");
}, 0);

Promise.resolve().then(() => {
  console.log("Promise 1");
});

setTimeout(() => {
  console.log("Timeout 2");
}, 0);

Promise.resolve().then(() => {
  console.log("Promise 2");
});

console.log("End");
```

출력:

```js
Start
End
Promise 1
Promise 2
Timeout 1
Timeout 2
```

---

### 🔹 **동작 설명**

1. `console.log("Start")`와 `console.log("End")`는 **동기적으로** 바로 실행된다.
2. `setTimeout`은 **매크로큐**에 대기하게 된다.
3. `Promise.resolve().then()`은 **마이크로큐**에 대기하게 되며, **매크로큐보다 우선순위가 높아** 먼저 실행된다.
4. `Timeout 1`과 `Timeout 2`는 매크로큐에 대기하고, **마이크로큐의 콜백이 모두 실행된 후**에 차례로 실행된다.

---

### **_🎯 결론_**

- 마이크로큐는 Promise와 같은 미세한 비동기 작업의 콜백이 대기하는 곳이며, 매크로큐는 setTimeout 같은 일반적인 비동기 작업의 콜백이 대기하는 곳이다.
- 마이크로큐의 우선순위가 매크로큐보다 높아서, 마이크로큐에 대기 중인 콜백이 먼저 실행된다.

---

## 5. 매크로태스크 VS 마이크로태스크

### ✅ 매크로태스크(Macro Task)와 마이크로태스크(Micro Task)

`매크로태스크`와 `마이크로태스크`는 자바스크립트의 `이벤트 루프`에서 `비동기 작업을 처리하는` 두 가지 주요 작업 유형이다. 둘의 가장 큰 **차이점**은 `실행 순서`와 `우선순위`에 있다.

---

### 🔹 **매크로태스크(Macro Task)**

- **매크로태스크**는 일반적인 비동기 작업을 처리하는 단위로, **setTimeout**, **setInterval**, **I/O 작업**, **UI 렌더링** 등이 포함된다.
- **우선순위가 낮다**. 콜 스택이 비어 있을 때만 실행된다.

---

### 🔹 **마이크로태스크(Micro Task)**

- **마이크로태스크**는 더 작은 비동기 작업을 처리하는 단위로, **Promise**의 **then**과 **catch** 콜백, **MutationObserver** 등이 포함된다.
- **매크로태스크보다 우선순위가 높다**. 마이크로태스크가 대기 중이면 매크로태스크가 실행되지 않는다.

---

### 🔹 **매크로태스크와 마이크로태스크의 동작 예시**

```js
console.log("Start");

setTimeout(() => {
  console.log("Macro Task 1");
}, 0);

Promise.resolve().then(() => {
  console.log("Micro Task 1");
});

setTimeout(() => {
  console.log("Macro Task 2");
}, 0);

Promise.resolve().then(() => {
  console.log("Micro Task 2");
});

console.log("End");
```

출력:

```
Start
End
Micro Task 1
Micro Task 2
Macro Task 1
Macro Task 2
```

---

### 🔹 **동작 설명**

1. `console.log("Start")`와 `console.log("End")`는 **동기적으로** 바로 실행된다.
2. `setTimeout`은 **매크로태스크**로 대기하며, `Macro Task 1`과 `Macro Task 2`는 콜 스택이 비어야 실행된다.
3. `Promise.resolve().then()`은 **마이크로태스크**로 대기하며, **매크로태스크보다 우선순위가 높아** 먼저 실행된다.
4. `Micro Task 1`과 `Micro Task 2`는 마이크로태스크로 대기하고, **매크로태스크가 실행되기 전에 모두 실행된다**.

---

### ✅ 매크로태스크(Macro Task)와 마이크로태스크(Micro Task)의 차이점

| **구분**      | **매크로태스크(Macro Task)**                        | **마이크로태스크(Micro Task)**                                     |
| ------------- | --------------------------------------------------- | ------------------------------------------------------------------ |
| **작업 종류** | `setTimeout`, `setInterval`, I/O 작업, UI 렌더링 등 | `Promise`의 `then/catch`, `MutationObserver` 등                    |
| **우선순위**  | 낮음                                                | 높음                                                               |
| **실행 순서** | 콜 스택이 비어야 실행됨                             | 매크로태스크가 실행되기 전에 실행됨                                |
| **실행 주기** | 이벤트 루프의 **각 주기마다 한 번** 실행            | 이벤트 루프가 각 주기를 시작하기 전에 **모든 마이크로태스크** 실행 |
| **예시**      | `setTimeout`, `setInterval` 등 비동기 작업 처리     | `Promise.resolve().then()`, `MutationObserver` 등                  |

---

### 🎯 **결론**

- **매크로태스크**는 `setTimeout`, `setInterval`, I/O 작업과 같은 일반적인 비동기 작업을 처리하는 단위이다.
- **마이크로태스크**는 `Promise`, `MutationObserver` 등 더 작은 비동기 작업을 처리하며, **매크로태스크보다 우선순위가 높다**.

---
### 그림으로 보는 이벤트루프, 매크로큐, 마이크로큐
![이벤트루프 흐름](https://i.imgur.com/sEf4Opl.png)

1. 매크로 태스크 큐에서 가장 오래된 태스크 를 꺼내서 실행시킨다.
2. 마이크로 태스크 큐에 있는 모든 태스크를 실행시킨다.
3. 렌더링 작업을 실행한다.
4. 매크로 태스크 큐에 새로운 매크로 태스크가 나타날 때까지 대기한다.
5. 1번으로 돌아간다.

![한눈에보는흐름](https://uploads.disquscdn.com/images/9466d8aa53fc5b3e63a92858a94bb429df02bbd20012b738f0461343beaa6f90.gif?w=600&h=272)

- 마이크로 태스크들은 실행하면서 새로운 마이크로 태스크를 큐에 추가할 수도 있다. 새롭게 추가된 마이크로 태스크도 큐가 빌 때까지 계속해서 실행된다.
- 반대로, 이벤트 루프는 매크로 태스크 큐에 있는 것을 실행시키기 시작할 때 있는 매크로 태스크만 실행시킨다. 매크로 태스크가 추가한 매크로 태스크는 다음 이벤트 루프가 실행될 때까지 실행되지 않는다.
---
# 🫡느낀점

- **느낀점**: 오늘은 비동기 처리에 대해서 배웠다 사실 아직 완전히 이해가 되지는 않지만 비동기 처리를 통해서 프로그램을 최적화 할 수 있다는 것을 알았다!
- **앞으로의 기대/목표**: 이러한 개념을 가지고 서버 비용 아끼고 성과를 내면 좋겠다!
---
## 💡아! 이런것도 있구나!
### ✅ MSA (Microservices Architecture)

- **MSA**는 애플리케이션을 작은 서비스 단위로 나누어 개발하는 아키텍처.
- 각 서비스는 **독립적으로 배포**되고, **독립적으로 개발, 운영, 확장** 가능.
- 서비스 간에는 **API**나 **메시지 기반 통신**을 사용하여 상호작용.
- **유연성**과 **확장성**이 뛰어나며, **빠른 배포**와 **유지보수 용이성**을 제공.
- 각 서비스는 특정 도메인에 집중하여 **독립적인 책임**을 맡음.
- **장점**: 시스템 복잡성 관리, 기술 스택 자유도, 장애 격리.
- **단점**: 서비스 간 통신 복잡도, 배포 및 관리의 어려움.
---
### ✅ STT (Speech-to-Text)

- **STT**는 음성 신호를 텍스트로 변환하는 기술.
- **음성 인식** 기술을 사용하여 사람의 말을 **컴퓨터가 이해할 수 있는 텍스트**로 변환.
- 음성 데이터는 **마이크로폰**을 통해 수집되고, **알고리즘**이 이를 분석해 텍스트로 전환.
- **주요 응용 분야**: 음성 명령, 음성 검색, 텍스트 입력 보조, 회의록 작성 등.
- **장점**: 빠르고 효율적인 텍스트 입력, 손과 눈을 사용하지 않고도 작업 가능.
- **단점**: **정확도**에 영향을 미치는 다양한 변수(배경 소음, 발음 차이 등).

### ✅ Fetch API

- `Fetch API는` **자바스크립트**에서 네트워크 요청을 보내고 응답을 처리하는 `비동기 API`.
- **XMLHttpRequest**의 대체 기술로, 더 직관적이고 `Promise 기반`으로 동작.
- 주로 `HTTP 요청(GET, POST 등)`을 보내거나 데이터를 가져오는 데 사용.
- **비동기 처리**를 위한 **`then()`**과 **`catch()`** 메서드를 사용하여 결과 처리.
- **예시 사용법**:
    ```js
  fetch('https://api.example.com/data')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.log('Error:', error));
    ```
- 장점: 간결한 문법, Promise 사용으로 비동기 코드 작성이 용이.
- 단점: 구형 브라우저에서 호환되지 않을 수 있으며, CORS 정책에 따른 제약이 있을 수 있음.

### ✅ Axios

- `Axios는` **자바스크립트**에서 HTTP 요청을 보내고 응답을 처리하는 `Promise 기반 라이브러리`.
- **Fetch API**의 대체 라이브러리로 사용되며, **비동기** 작업을 더 간편하게 처리할 수 있음.
- **주요 기능**: GET, POST, PUT, DELETE 요청 등 다양한 HTTP 메서드 지원.
- **브라우저와 Node.js** 환경에서 모두 사용할 수 있음.
- **자동으로 JSON 데이터 처리** 및 **응답 데이터 변환**.
- **예시 사용법**:
  ```js
  axios.get('https://api.example.com/data')
    .then(response => console.log(response.data))
    .catch(error => console.log('Error:', error));
    ```
- 장점:
1. 자동으로 JSON 데이터를 처리.
2. 인터셉터를 통해 요청이나 응답을 가로채기 가능.
3. 요청 취소 기능이 내장되어 있어 요청을 중단할 수 있음.
- 단점:
Fetch API보다 더 많은 코드와 용량을 차지할 수 있음.
